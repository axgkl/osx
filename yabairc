#!/usr/bin/env python3
from functools import partial
from lima import Lima
from const import FSPC, S, YabaiMenuApp, quit_app

import sys
import os
import threading
import time
import json
from time import ctime
import subprocess
import reactivex as Rx
from reactivex import operators as rx
from reactivex.scheduler import ThreadPoolScheduler
from AppKit import NSWorkspace, NSRunningApplication, NSImage, NSBitmapImageRep

sys.path.insert(0, os.environ["HOME"] + "/.config/yabai")
from spec import arrange_spec

pidfile = lambda: f"{S.fn_fifo}.pid"
logfile = lambda: f"{S.fn_fifo}.log"
Y = "/opt/homebrew/bin/yabai"


def log(*msg):
    print(*msg)
    with open(logfile(), "a") as f:
        f.write(" ".join(map(str, msg)) + "\n")
    S.lognr += 1
    if S.lognr < 1000:
        return
    with open(logfile(), "w") as f:
        f.write("cleared log")
    S.lognr = 0


def switchwin(_, wid):
    os.system(f"yabai -m window --focus {wid}")


def switchspace(_, sid):
    os.system(f"yabai -m space --focus {sid}")


def focus_win(win):
    if win["app"] == "Dock":
        return
    cmd = f"yabai -m window --focus {win['id']}"
    os.system(cmd)


def makeico(win):
    win["callback"] = partial(switchwin, wid=win["id"])
    win["menu"] = win.get("title", "")[:30]
    win["ico"] = get_app_icon(win)
    # focus_win(win)
    return win


d_icos = os.path.abspath(os.path.dirname(__file__)) + "/icos"


def get_app_icon(win):
    fn = f"{d_icos}/{win['app']}.png"
    if os.path.exists(fn):
        return fn
    id = NSRunningApplication.runningApplicationWithProcessIdentifier_
    app = id(win["pid"])
    if not app:
        return
    icon = app.icon()
    if not icon:
        return
    bitmap_rep = NSBitmapImageRep.imageRepWithData_(icon.TIFFRepresentation())
    png = bitmap_rep.representationUsingType_properties_
    with open(fn, "wb") as f:
        f.write(png(4, None))
    return fn


def rebuild_wins():
    old = {wid: w for wid, w in S.windows.items()}
    S.windows.clear()
    try:
        print("wins")
        output = os.popen(Y + " -m query --windows").read().strip()
        data = json.loads(output)
        S.windows = {w["id"]: old.get(w["id"]) or makeico(w) for w in data}
    except Exception:
        return


def toggle_darkmode(*_):
    cmd = "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'"
    os.system(cmd)


def add_window(wid, add):
    w = S.windows.get(wid)
    if w is None:
        rebuild_wins()
        w = S.windows.get(wid)
        if not w:
            return
    add(w["menu"], w["callback"], ico=w["ico"])


def system_sleep(_):
    os.system("pmset sleepnow")


def yabai_restart(_):
    os.system("yabai --restart-service")
    # os.system("osascript -e 'tell application \"System Events\" to sleep'")


sep = "â”€"


d_icos = os.path.abspath(os.path.dirname(__file__)) + "/icos"


def get_app_icon(win):
    fn = f"{d_icos}/{win['app']}.png"
    if os.path.exists(fn):
        return fn
    id = NSRunningApplication.runningApplicationWithProcessIdentifier_
    app = id(win["pid"])
    if not app:
        return
    icon = app.icon()
    if not icon:
        return
    bitmap_rep = NSBitmapImageRep.imageRepWithData_(icon.TIFFRepresentation())
    png = bitmap_rep.representationUsingType_properties_
    with open(fn, "wb") as f:
        f.write(png(4, None))
    return fn


def querywin(win):
    win = {}
    try:
        output = os.popen(Y + " -m query --windows --window").read().strip()
        win = json.loads(output)
        win["ico"] = get_app_icon(win)
    except Exception:
        pass
    S.cur_win = win
    return win


def window(wid):
    S.windows[wid] = win = S.windows.get(wid) or querywin(wid)
    return win


def mv_win(win):
    a = win["app"].lower()
    for nr, app in arrange_spec:
        if app in a:
            cmd = Y + f" -m window {win['id']} --space {nr}"
            return os.system(cmd)


def spaces():
    output = os.popen(Y + " -m query --spaces").read().strip()
    return json.loads(output)


def arrange_wins(*_):
    output = os.popen(Y + " -m query --windows").read().strip()
    wins = json.loads(output)
    [mv_win(win) for win in wins]
    s = len(spaces())
    [os.system(Y + f" -m space {nr} --balance") for nr in range(s)]


def build_spc_menu(_=None):
    S.app.menu.clear()
    S.app.add("ðŸ” Refresh Menu", build_spc_menu)
    S.app.add("ðŸ§¹ Arrange", arrange_wins)
    S.app.add("â˜¯ Dark/White", toggle_darkmode)
    S.app.add("ðŸŒ™ System Sleep", system_sleep)
    S.app.add("ðŸ” Restart Yabai", yabai_restart)
    S.app.add("ðŸšªQuit Menu", quit_app)
    Lima.build_menu()


# def start_docker_default(_):
#     cmd = "docker context use lima-docker-default"
#     os.system(cmd)
#     cmd = "docker start gk-docker"
#     os.system(cmd)
#     cmd = "docker ps -a"
#     output = os.popen(cmd).read().strip()
#     log(output)


noop = lambda *_: None
wins = [
    ["title", noop, ""],
    "id",
    "pid",
    "app",
    "scratchpad",
    "frame",
    "role",
    "subrole",
    "root-window",
    "display",
    "space",
    "level",
    "sub-level",
    "layer",
    "sub-layer",
    "opacity",
    "split-type",
    "split-child",
    "stack-index",
    "can-move",
    "can-resize",
    "has-focus",
    "has-shadow",
    "has-parent-zoom",
    "has-fullscreen-zoom",
    "has-ax-reference",
    "is-native-fullscreen",
    "is-visible",
    "is-minimized",
    "is-hidden",
    "is-floating",
    "is-sticky",
    "is-grabbed",
]
wins = [w if isinstance(w, list) else [w] for w in wins]


def win_menu_add(key, cb=None, title=None):
    if title is None:
        title = f"{key}:"
    v = S.cur_win.get(key, "")
    cb = noop
    S.app.add(f"{title}{v}", cb)


def build_win_menu():
    S.app.menu.clear()
    for l in wins:
        win_menu_add(*l)


class Evts:
    def none(evt):
        print(evt)

    def space_changed(evt: list):
        spaceidx = int(evt[2])
        S.menutitle["space"] = FSPC.get(spaceidx, 1)
        S.app.set_title()

    def window_destroyed(evt: list):
        S.windows.pop(evt[1], 0)

    def window_focused(evt: list):
        print(len(S.windows))
        wid = evt[1]
        fnico = window(wid)["ico"]
        if fnico:
            S.app.icon = fnico
        build_win_menu()

    # def ghostty_created(evt: list):
    #     os.system('yabai -m query --spaces --space |jq ".index" ')


def setup_fifo_listener():
    s = Rx.from_iterable(fifo_stream()).pipe(
        rx.map(lambda x: x.split()),
        rx.group_by(lambda x: x[0]),
        rx.flat_map(lambda s: s.pipe(rx.map(getattr(Evts, s.key, Evts.none)))),
        # rx.map(lambda _: S.app.draw()),
    )
    s.subscribe(
        on_next=lambda _: None,
        on_error=lambda e: log(f"Error in stream: {e}"),
        scheduler=ThreadPoolScheduler(),
    )


def fifo_stream():
    while True:
        with open(S.fn_fifo, "r") as fifo:
            for line in fifo:
                yield line.strip()


if __name__ == "__main__":
    S.fn_fifo = sys.argv[1]
    S.mode = "s" if "spc" in S.fn_fifo else "w"
    time.sleep(0.2 if S.mode == "s" else 0)
    os.system(f"kill `pgrep -F {pidfile()}`")
    with open(pidfile(), "w") as f:
        f.write(str(os.getpid()))

    log(f"Starting up {ctime()}")
    Lima.prepare_docker_socket()
    os.makedirs(d_icos, exist_ok=True)
    if not os.path.exists(S.fn_fifo):
        os.mkfifo(S.fn_fifo)
    while True:
        try:
            setup_fifo_listener()
            S.app = YabaiMenuApp()
            S.app.build_menu = build_win_menu
            if S.mode == "s":
                Evts.space_changed([0, 0, "1"])
                S.app.build_menu = build_spc_menu
                S.app.build_menu()
            S.app.run()
        except KeyboardInterrupt:
            break
        except Exception as e:
            log(f"Error: {e}")
            time.sleep(1)
            continue
        finally:
            log("Exiting...")
            os.remove(pidfile())
            break
